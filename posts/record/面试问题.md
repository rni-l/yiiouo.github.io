---
title: 面试问题
date: 2019-02-07
tags: ["面试"]
categories: ["记录"]
draft: true
---

### JavaScript

1. 什么是闭包？

    闭包就是当一个函数内有引用函数外的变量，而且该函数在函数外被引用，就会使该函数使用的变量没有被内存回收，维持着当前的状态。

2. 什么是作用域？

    作用域是一套规则，规定在何处如何查找变量

    JavaScript 使用的是词法作用域，词法作用域是定义在词法阶段，就是代码将变量和块作用域写在哪里决定（词法作用域由函数被声明时所在的位置所决定）

    当要查询一个变量的时候，会先在当前的作用域查找，找不到就会一级级往上找，直到全局作用域为止

3. 什么是原型？什么是原型链？

4. 基本类型

    1. Boolean
    2. Undefined
    3. Null
    4. Number
    5. String
    6. Symbol

5. 引用类型

    1. Object
    2. Array
    3. Function
    4. RegExp
    5. Date

#### 内存泄露

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

JS 有自己的垃圾回收机制，自动的内存管理，使用的是“引用计数”。当一个值没有被引用，就会被回收，否则一直存在内存中。

要注意全局方法里引用的对象，像 setInterval、dom 的添加事件的回调函数，要使用专门的销毁方法，clearInterval、removeEventListener 这些方法。

#### JS EventLoop 原理

JS 是单线程，这里引用阮一峰老师文章的内容：

> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
>
> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

JS 里面有分同步和异步，同步任务直接在主线程执行，异步任务会加入到一个任务队列中，等主线程的任务完成了后，就会执行异步任务。JS 会不停循环这个过程。

1. 将同步任务放到调用栈，将异步任务加到任务队列中，其中的异步任务会分为 task 和 mircotask，像 AJAX、setTimeout 这些是 task，而 Prmose 则是 mircotask
2. 首先执行同步任务
3. 然后执行 mircotask queue 中的任务（promise）
4. 然后执行其他 task（DOM 回调、AJAX、setTimout）
5. 然后一直循环上面的顺序

### css

#### rem 原理

rem 单位兼容 IE9 以上，基本上移动端的浏览器都支持。它是根据 HTML 的字体大小而变化。1rem 就等于多少字体大小。而移动端的 rem 布局原理，就是根据浏览器的宽度、一个基准值而改变 HTML 的字体大小，再添加阿里的 flexible 方案，从而形成动态缩放的效果。

设置一个基准值，flexible 这个库就会根据当前浏览器的宽度，重新计算 HTML 的字体大小。比如设置基准值是 75，设计稿的宽度是 750px 的

 在 750 宽的浏览器，HTML 的字体大小就是 75px，1rem 就等于 75px 。而我写某个样式时，直接就可以根据设计稿的大小 / 基准值，就是所要的 rem 值。再配上自动转换工具，可以直接写上 px。

#### link 和 @import 区别

1. link 可以多个同时加载；@import 需要等页面加载完成后再加载
2. link 没有兼容问题；@import 低版本 ie 不支持(ie5)
3. link 可以通过 js 动态插入，@import 不行

#### border 三角形原理

每个位置的边框，其实是有三角形形成的

![](http://md.rni-l.com/md/20200107235153.png)

[原文](https://www.jianshu.com/p/9a463d50e441)

#### 什么是 BFC

处于 BFC 的子级，与外部的元素互不干扰，是一个完全独立的区域，例如 margin，如果不是 BFC 状态，margin 的效果会影响到外部元素；计算 BFC 的高度时，浮动子元素也会算上

有什么方法可以触发 BFC

1. overflow 不是 visible 
2. position 不是 static 和 relative
3. display 是 flex 和 inline-block
4. float 不是 none

### 框架

#### vue

##### 为什么使用 vue

简单易上手，官方文档、教程很友好，很快就可以开发项目。而且官方有一套完整的生态，可以很快得开发一个简单的项目。而 vue 的单文件组件，我觉得开发起来更方便，不需要不断地切换文件

vue-cli 3.x 版本，可以快速建一个 TypeScript 项目，而且 vue3.0 版本是用 TypeScript 重构的，未来 vue 对 TypeScript 会更加得友好

而且 vue 在国内的生态非常得热，对于项目出现问题的解决办法，也会有很多

##### 组件通信的方式

父子：

1. 通过传入 props，给到子组件
2. 通过 refs 直接获取子组件的属性、或调用方法

子父：

1. 通过 emit 方法，通知父组件
2. 获取 this.$parent ，得到父组件

兄弟、或无关联组件

1. eventBus
2. vuex

##### computed 和 watch 区别

computed：

1. 可以对多个属性进行监控，某个属性发生变化，就会调用定义的函数，相当于声明一个新的属性
2. 而且 computed 会基于里面的属性进行缓存，只有相关的属性发生变化才会重新求值。所以当里面的属性没有变化时，重复的获取 computed 的值，只是从缓存里拿，而没有再次执行里面的代码

watch：

1. 对某个属性近监控，当这个属性发生变化，就会调用定义的函数
2. 只有属性变化才会触发这个回调，更多地是当属性变化从而处理一些业务逻辑

##### nextTick 原理





#### 为什么使用 react

react 上手也是很快，单项数据流，数据流自上而下，显示清晰，debug 方便。而且 react 生态很火热，在 github 上有各种各样的功能库，足够满足很多项目需要的功能

#### vuex 和 redux 的区别

1. vuex 和 redux 都是基于一个状态树进行维护数据
2. redux 的 store 是不可变的，只能通过 reducer 得到的 state 进行替换；而 vuex 的 store 通过 mutation 对某个变量进行修改，而不是整个替换
3. vuex 的异步处理，有自带的 action；而 redux 可以选择不同的第三方库配合 middleware 进行处理

单一状态树的好处：能够直接地定位任一特定的状态片段，也能很容易地获取整块数据的快照

vuex

1. 要修改 store 里面的数据，要显示调用 mutation 才可以，这是为了可以追踪每一次状态的变化
2. action 类似于 mutation，它可以调用 mutation，但不能直接修改状态值，在 action 可以包含任意异步操作
3. 为什么 mutation 必须同步函数？这是作者的一种约定，mutation 是同步函数，才能让开发工具捕捉到每次的状态变更。因为 mutation 触发后， devtool 不知道回调函数什么时候才被调用，所以无法追踪数据变化。

vuex 概念：vuex 是专门配合 vue 的一个状态管理库，由一个状态树维护数据，它有几个核心的概念： state 就是一个状态树，保存着全部的状态；getter 用于封装业务逻辑从而获取数据的方法；mutation 是唯一能修改 state 的同步方法；action 用于处理异步操作的方法，不能直接修改数据，但能调用 mutation 去修改；module 划分不同的模块。其实整个状态管理库并不复杂，用 state 保存全部数据，只能通过 mutation 去修改 state 的值，当 state 修改后，就会通知 view 层进行更新操作。

redux

1. dispatch ，触发 action 传到 store，而 action 是 store 数据的唯一来源。官方的约定是 action 是一个 Object 的数据结构， type 字段是声明要执行的动作类型，其余是要传入的数据字段。**action 只是描述有什么事情发生**

2. reducer 是响应 dispatch 传入的 action，进行处理后再发送到 store 的纯函数。**reducer 是描述如何更新 state 值**。reducer 接收两个参数：state 和 action。官方约定 reducer 是纯函数，不能有

    1. 修改传入参数
    2. 执行有副作用的操作（请求 api 和路由跳转）
    3. 调用非纯函数（Date.now()) ??

    reducer 里面不要修改 state 值，而是通过生成新的属性，例如用 Object.assign

redux 概念：单向数据流，维护唯一的、不可变的 store，state 的值是不可直接修改的，要通过触发 action 后，state 再去响应对应的 reducer，最后替换 state 值 。

什么是不可变数据：

不可变数据就是你不能直接修改它的值，而是通过复制它的值，并且产生一个新对象的方式来得到一个新的数据，包含里要修改的部分

不可变数据的优势：

带来更高的性能，更简单的调试，不会改变的数据比可以随意更改的数据更容易调试。

##### redux 的异步处理

像请求  API ，大概分为三个状态，start，success，fail

###### 最简单的处理

首先在 component 里面，开始请求 api，随即修改请求状态为：start；当收到响应后，如果是成功，修改状态为：success，否则修改状态为：fail

存在问题：

1. 每次写请求的代码，都需要重复这些代码
2. 没有做竟态处理，当某个请求还没收到响应时，其他请求收到了响应，导致数据渲染有误

###### 异步 action



### 工具

#### webpack

构建流程

1. 解析webpack配置参数。
2. 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。
3. 从配置的`entry`入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。
4. 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。
5. 而 plugin 可以扩展功能，比如打包优化、资源管理等
6. 递归完后得到每个文件的最终结果，根据`entry`配置生成代码块`chunk`。
7. 根据 `output` 的配置，输出所有`chunk`到文件系统。

### 网络

#### 跨域

同源策略是浏览器的一个限制，同源是值“协议+域名+端口”一致，否则非同源。

#### 解决跨域问题

1. JSONP
2. CORS，后端在 HTTP 请求的时候添加跨域头字段
3. postMessage，解决多窗口之间，嵌套的 iframe，页面与新打开的窗口的消息传递
4. 后端代理，后端服务通过请求对应的地址，将响应返回给前端，由后端实现
5. nginx 反向代理，类似后端代理，使用 nginx 转发请求



#### HTTPS 能做什么？有什么用

HTTPS 就是在 HTTP 基础上多了一层 SSL，SSL 协议拥有加密、CA 的功能，可以建立一个信息安全通道，确认内容的真实性

使用 HTTPS 是代替 HTTP，HTTP 有一些不足的地方

1. 通信使用明文，内容会被窃取

    HTTP 是基于 TCP/IP 的，通信内容有可能被窥视（为啥 TCP 传输内容会被窥视？）

2. 不验证通信方的身份，通信会被遭遇伪装

    1. HTTP 协议的请求和响应，不会对通信方进行确认（通信的对方，是否你要指定的主机）
    2. 任何人都可以对某个主机发起请求

3. 无法证明报文的完整性，内容会被篡改

    1. 无法证明信息的完整性，内容可能会在传输中，被攻击者篡改

而 HTTPS 解决上面的问题

1. 建立安全的通信通道，内容无法被窃取、篡改，保证完整性
2. 服务器和客户端某一方拥有 CA 的话，即可判断通信方的真实存在

#### HTTP2.0

HTTP2.0 能显著提高性能

1. 多路复用（Multiplexing），能允许同时通过单一的 HTTP/2 连接发起多重的请求- 响应消息，在同一个连接上进行交互数据；而HTTP1.x 版本，会对同一域名有限制的发送请求。所以减少了服务端的链路压力，连接吞吐量更大
2. 首部压缩，传说的体积更少
3. 服务端推送



### 平时项目开发遇到什么问题？怎么解决？

#### 使用 keep-alive 组件，解决后退页面时，保存之前的状态

项目需求，在 A 页面点击某个按钮跳去 B 页面时，再回到 A 页面时，要保存之前的状态，而其他情况进入该页面要刷新的状态。使用 keep-alive 组件和 keep-alive 的 include 属性，判断哪些页面组件需要缓存。再加上 vuex 去动态的控制哪些页面在什么时候需要缓存，在 `activated` 和 `deactivated` 的钩子函数中，去判断是否要缓存页面。还有根据 route 的 meta 属性也可以。

原本的思路是，全部组件都用 keep-alive 的组件，然后需要销毁组件的时候，在 deactivated 的钩子函数中，使用 destory 方法。但页面组件使用了该方法后，后面的路由会混乱，比如后退时，去到的页面组件并不是实际要去到的。

#### 在做管理后台的项目时，根据业务需求，对 element-ui 的组件做二次封装

因为管理后台用的是 第三方的 UI 组件，比如 element-ui，而需求使用定制不一样的样式，所以把用到的 element-ui 组件做二次封装，定制样式。比如 Dialog 样式，顶部的样式、底部的按钮组。还有 Table 组件，添加默认样式和默认配置，普通的栏直接用传入配置和数据即可，无需再写 html，特殊的栏可以用 slot-scope。还有其他的 Select 组件、Checkbox 组件、分页组件等等。

#### 使用 easy-mock 模拟数据，可以不用等后端有接口才开始写逻辑，加快开发速度

我之前开发的项目很多都是前后端分离的，前端切完图之后，就要等后端有接口和文档，才能继续开发。然后我们就产品原型出了之后，后端就会尽快出接口文档，定好返回值的 key 值和类型。我们后端用的是 swagger 生成文档的，swagger 可以导出一份 json 文件，再放到 easy-mock （一个网站）上，就可以直接拿来用，会返回假的数据。

#### 使用脚手架，为模板项目快速开发

有一个模板项目，分别有3个项目仓库，每次要开一个新项目的时候都很麻烦，要下载三个项目仓库，安装依赖、配置文件等。使用 Node 搞了个简单的脚手架，一键下载三个仓库并安装依赖，并且显示输入框，输入配置内容。

### 其他

#### 自我介绍

我现在工作了两年半，其中一年是实习。用 vue 开发大概有一年半的时间。平时开发的项目主要是微信端的网页、H5，管理后台、响应式网站、微信小程序等。也有用过 React、NodeJs、TypeScript 开发过一些小项目。

#### 问公司的问题

1. 贵公司的主要核心、盈利业务是什么？
2. 开发团队、部门有多少人，各是什么类型
3. 前端部门主要用的技术栈是什么？
4. 一个项目的开发，前端是怎么分配任务？怎么协调合作的？
5. 公司福利等